// ****************************************************************************
// A small C program to create DIMACS CNF files that encode the pigeonhole
// problem (i.e. placing n+1 pigeons into n holes).
//
// The SAT encoding of this problem is very straightforward.
// The variables can be ordered in either pigeon-major or hole-major order
//
// For each pigeon i and each hole j we have a variable x_{n*(i-1)+j}
// (pigeon-major) or x_{n*(j-1)+i} (hole-major) which means that
// pigeon i is placed in hole j.  Then we have n+1 clauses which say
// that a pigeon has to be placed in some hole.  Then for each hole we
// have a set of clauses ensuring that only one single pigeon is
// placed into that hole.
//
// This encoding leads to a total of (n+1) * n propositional variables and
// (n+1) + n * (n * (n+1) / 2) clauses.
//
// The resulting SAT problem is unsatisfiable.
//
// Version 1.0, 2007-03-15
// (c) 2007 Tjark Weber
// Modifications
// 2020-05-21.  Support hole-major ordering.  Randal E. Bryant
// ****************************************************************************

#include <stdlib.h>
#include <stdio.h>

void usage() {
    printf("Usage:\n");
    printf("\n");
    printf("  pigeonhole n\n");
    printf("\n");
    printf("where |n| is the number of holes (the number of pigeons is |n|+1).\n");
    printf("where n>0 orders the variables in pigeon-major order.\n");
    printf("where n<0 orders the variables in hole-major order.\n");
    exit(1);
}

int main(int argc, char** argv) {

    int n = 4;  // n+1 pigeons in n holes
    int hole_major = 0;

    int i, k;  // pigeons i, k
    int j;     // hole j

    int clause_count = 0;  // How many clauses have been generated

    if (argc != 2)
	usage();

    n = atoi(argv[1]);

    if (n == 0)
	usage();

    
    if (n < 0) {
	hole_major = 1;
	n = -n;
    }


    // DIMACS header
    printf("c pigeon-%d: placing %d pigeons into %d holes\n", n, n+1, n);
    printf("c \n");
    printf("c File generated by 'pigeonhole', (c) Tjark Weber, (c) Randal E. Bryant\n");
    printf("c \n");
    printf("c The SAT encoding of this problem is very straightforward.  For each pigeon i\n");
    if (hole_major)
	printf("c and each hole j we have a variable x_{n*(j-1)+i} which means that pigeon i\n");
    else
	printf("c and each hole j we have a variable x_{n*(i-1)+j} which means that pigeon i\n");
    printf("c is placed in hole j.  Then we have n+1 clauses which say that a pigeon has\n");
    printf("c to be placed in some hole.  Then for each hole we have a set of clauses\n");
    printf("c ensuring that only one single pigeon is placed into that hole.\n");
    printf("c \n");
    printf("c This encoding leads to a total of (n+1) * n propositional variables and\n");
    printf("c (n+1) + n * (n * (n+1) / 2) clauses.\n");
    printf("c \n");
    printf("c The resulting SAT problem is unsatisfiable.\n");
    printf("c \n");
    printf("p cnf %d %d\n", (n+1) * n, (n+1) + n * (n * (n+1) / 2));

    // n+1 clauses which say that a pigeon has to be placed in some hole
    for (i=1; i <= n+1; i++) {
	for (j=1; j <= n; j++) {
	    int index;
	    if (hole_major) {
		index  = (n+1)*(j-1)+i;
	    } else {
		index  = n*(i-1)+j;
	    }
	    printf("%d ", index);
	}
	printf("0\n");
	clause_count++;
	// Generate ALO for pigeon i
	printf("c PSEUDO c %d\n", clause_count);
	printf("c PSEUDO >= 1");
	for (j=1; j <= n; j++) {
	    int index;
	    if (hole_major) {
		index  = (n+1)*(j-1)+i;
	    } else {
		index  = n*(i-1)+j;
	    }
	    printf(" 1.%d", index);
	}
	printf("\n");
    }

    // for each hole we have a set of clauses ensuring that only one single
    // pigeon is placed into that hole
    for (j=1; j <= n; j++) {
	int start_clause = clause_count+1;
	for (i=1; i <= n; i++)
	    for (k=i+1; k <= n+1; k++) {
		int index, kindex;
		if (hole_major) {
		    index  = (n+1)*(j-1)+i;
		    kindex = (n+1)*(j-1)+k;
		} else {
		    index  = n*(i-1)+j;
		    kindex = n*(k-1)+j;
		}
		printf("-%d -%d 0\n", index, kindex);
		clause_count++;
	    }
	int last_clause = clause_count;
	/* Generate AMO constraint for hole j */
	printf("c PSEUDO c");
	for (k = start_clause; k <= last_clause; k++)
	    printf(" %d", k);
	printf("\n");
	int acount = last_clause - start_clause;
	if (acount > 0)
	    printf("c PSEUDO a %d\n", acount);
	printf("c PSEUDO >= -1");
	for (i=1; i <=n+1; i++) {
	    int index;
	    if (hole_major)
		index  = (n+1)*(j-1)+i;
	    else
		index  = n*(i-1)+j;
	    printf(" -1.%d", index);
	}
	printf("\n");
    }
    return 0;
}
