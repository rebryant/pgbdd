This directory contains the code for the QBF solver pgbddq and for
qchecker, a proof checker that can check proofs generated by pgbddq.

Files:

	qsolver.py    The main solution code
	bdd.py	      A proof-generating BDD package
	proof.py      Generates proofs in QPROOF and QRAT proofs
	resolver.py   Support for generating resolution proofs

	qchecker.py   Standalone program for checking proofs in QPROOF format.

The following documents the format of QPROOF files.  This text is
taken from comments at the beginning of the file qproof.py.

Each proof step is written on a separate line.
Any line beginning with 'c' is treated as a comment.

Proofs generally start with a series of level shifts.

######################################################################################
# Checker format
######################################################################################
# Notation
#  Id: Clause Id
#  Var: Variable
#  Lit: Literal +/- Var
#  Level: Quantification level

# [Lit*]: Clause consisting of specified literals
# C[Id]: Clause with given Id
# Var(Lit): Variable for specified literal

### All proof types

# - l Level Var+ 0
#    Shift input variables to specified level
#    All shifts must occur before any other command type
#    Check that resulting ordering of input variables is a refinement of the initial ordering
#    A minimal shift would be to move each variable at level l to 2l-1 to make room for existential variables

# - x Level Var+ 0
#    Introduce extension variable(s) at specified quantification level
#    Make sure each Var is not already defined, and that only existential variables are at this level

### Refutation and dual proofs

# Id ar Lit* 0 Id+ 0
#    Add clause C[Id] = [Lit*] by resolution.
#    Must check that antecedents resolve to clause
#    Also incorporates subsumption, i.e., if C' subset C, the C' ==> C.
#    Must check that antecedents resolve to clause C' that is
#     (perhaps improper) subset of C[Id]


# Id ab Lit+ 0 -Id* 0
#    Add blocked clause C[Id] = [Lit+].  Blocking literal L must be first
#    Negative Ids are those clauses containing -L
#    Must make sure no other clauses contain -L
#    Must make sure every clause containing -L contains literal L'
#      such that L' in [Lit+]

# Id u Lit Id'

#    Universal reduction.  Remove literal Lit from clause Id' to get
#      C[Id] = C[Id'] - { Lit }
#    Must check that Var(Lit) is greater than Var(Lit') for any Lit'
#      in C[Id']
#    OK if Lit is not in clause

### Refutation-only proofs

# - d Id+ 0
#    Delete clauses.  Must make sure they are live

### Satisfaction and dual proofs

# - dr Id Id+ 0
#    Delete clause C[Id] by resolution.
#    Also incorporates subsumption, i.e., if C' subset C, the C' ==> C.
#    Must check that antecedents resolve to clause C' that is
#     (perhaps improper) subset of C[Id]

# - dd Var Id+ 0 Id* 0
#    Delete all clauses in first list by
#    Davis-Putnam reduction on variable Var (Also called "Existential elimination")
#    Second list consists of all resolvents from first list
#      w.r.t. resolution variable Var
#    No clauses other than those in first list can contain Var or -Var
#    None of these can contain a universal literal > Var

### Satisfaction-only proofs

# Id a Lit* 0
#    Add clause C[Id] = [Lit*].

######################################################################################
